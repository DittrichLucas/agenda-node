{"version":3,"file":"InjectRepository.js","sourceRoot":"","sources":["../../../src/decorators/InjectRepository.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConnectionManager, Repository, TreeRepository, MongoRepository } from 'typeorm';\nimport { Constructable, Container } from 'typedi';\n\nimport { EntityTypeMissingError } from '../errors/EntityTypeMissingError';\nimport { PropertyTypeMissingError } from '../errors/PropertyTypeMissingError';\nimport { ParamTypeMissingError } from '../errors/ParamTypeMissingError';\n\n/**\n * Helper to avoid V8 compilation of anonymous function on each call of decorator.\n */\nfunction getRepository(connectionName: string, repositoryType: Function, entityType: Function) {\n  const connectionManager = Container.get(ConnectionManager);\n  if (!connectionManager.has(connectionName)) {\n    throw new Error(\n      `Cannot get connection \"${connectionName}\" from the connection manager. ` +\n        `Make sure you have created such connection. Also make sure you have called useContainer(Container) ` +\n        `in your application before you established a connection and importing any entity.`\n    );\n  }\n  const connection = connectionManager.get(connectionName);\n\n  switch (repositoryType) {\n    case Repository:\n      return connection.getRepository(entityType);\n    case MongoRepository:\n      return connection.getMongoRepository(entityType);\n    case TreeRepository:\n      return connection.getTreeRepository(entityType);\n    // if not the TypeORM's ones, there must be custom repository classes\n    default:\n      return connection.getCustomRepository(repositoryType);\n  }\n}\n\n/**\n * Satisfy typescript compiler about universal decorators.\n */\nexport type ParamOrPropDecorator = (object: object, propertyName: string, index?: number) => void;\n\n/**\n * Allows to inject a custom repository using TypeDI's Container.\n * Be aware that you have to annotate the param/property  with correct type!\n * ```ts\n * class Sample {\n *   // constructor injection\n *   constructor(\n *     \\@InjectRepository()\n *      private userRepository: UserRepository,\n *   ) {}\n *\n *   // property injection\n *  \\@InjectRepository()\n *   userRepository: UserRepository;\n * }\n * ```\n */\nexport function InjectRepository(): ParamOrPropDecorator;\n/**\n * Allows to inject a Repository, MongoRepository, TreeRepository using TypeDI's Container.\n * Be aware that you have to annotate the param/property  with correct type!\n * ```ts\n * class Sample {\n *   // constructor injection\n *   constructor(\n *     \\@InjectRepository(User)\n *      private userRepository: Repository<User>,\n *   ) {}\n *\n *   // property injection\n *  \\@InjectRepository(User)\n *   userRepository: Repository<User>;\n * }\n * ```\n */\nexport function InjectRepository(entityType: Function): ParamOrPropDecorator;\n/**\n * Allows to inject a custom repository using TypeDI's Container\n * and specify the connection name in a parameter.\n * Be aware that you have to annotate the param/property  with correct type!\n * ```ts\n * class Sample {\n *   // constructor injection\n *   constructor(\n *     \\@InjectRepository(\"test-conn\")\n *      private userRepository: UserRepository,\n *   ) {}\n *\n *   // property injection\n *  \\@InjectRepository(\"test-conn\")\n *   userRepository: UserRepository;\n * }\n * ```\n */\nexport function InjectRepository(connectionName: string): ParamOrPropDecorator;\n/**\n * Allows to inject a Repository, MongoRepository, TreeRepository using TypeDI's Container\n * and specify the connection name in a parameter.\n * Be aware that you have to annotate the param/property with correct type!\n * ```ts\n * class Sample {\n *   // constructor injection\n *   constructor(\n *     \\@InjectRepository(User, \"test-conn\")\n *      private userRepository: Repository<User>,\n *   ) {}\n *\n *   // property injection\n *  \\@InjectRepository(User, \"test-conn\")\n *   userRepository: Repository<User>;\n * }\n * ```\n */\nexport function InjectRepository(entityType: Function, connectionName: string): ParamOrPropDecorator;\n\nexport function InjectRepository(\n  entityTypeOrConnectionName?: Function | string,\n  paramConnectionName = 'default'\n): ParamOrPropDecorator {\n  return (object: object, propertyName: string, index?: number) => {\n    let entityType: Function | undefined;\n    let connectionName: string;\n    let repositoryType: Function;\n\n    // handle first parameter overload\n    connectionName = paramConnectionName;\n    if (typeof entityTypeOrConnectionName === 'string') {\n      connectionName = entityTypeOrConnectionName;\n    } else if (typeof entityTypeOrConnectionName === 'function') {\n      entityType = entityTypeOrConnectionName;\n    }\n\n    // if the decorator has been aplied to parameter (constructor injection)\n    if (index !== undefined) {\n      const paramTypes: Function[] | undefined = Reflect.getOwnMetadata('design:paramtypes', object, propertyName);\n      if (!paramTypes || !paramTypes[index]) {\n        throw new ParamTypeMissingError(object, propertyName, index);\n      }\n      repositoryType = paramTypes[index];\n    }\n    // if the parameter has been aplied to class property\n    else {\n      const propertyType: Function | undefined = Reflect.getOwnMetadata('design:type', object, propertyName);\n      if (!propertyType) {\n        throw new PropertyTypeMissingError(object, propertyName);\n      }\n      repositoryType = propertyType;\n    }\n\n    switch (repositoryType) {\n      case Repository:\n      case MongoRepository:\n      case TreeRepository:\n        if (!entityType) {\n          throw new EntityTypeMissingError(object, propertyName, index);\n        }\n    }\n\n    Container.registerHandler({\n      index,\n      object: object as Constructable<unknown>,\n      propertyName,\n      value: () => getRepository(connectionName, repositoryType, entityType!),\n    });\n  };\n}\n"]}