import { ConnectionManager, Repository, TreeRepository, MongoRepository } from 'typeorm';
import { Container } from 'typedi';
import { EntityTypeMissingError } from '../errors/EntityTypeMissingError';
import { PropertyTypeMissingError } from '../errors/PropertyTypeMissingError';
import { ParamTypeMissingError } from '../errors/ParamTypeMissingError';
/**
 * Helper to avoid V8 compilation of anonymous function on each call of decorator.
 */
function getRepository(connectionName, repositoryType, entityType) {
    const connectionManager = Container.get(ConnectionManager);
    if (!connectionManager.has(connectionName)) {
        throw new Error(`Cannot get connection "${connectionName}" from the connection manager. ` +
            `Make sure you have created such connection. Also make sure you have called useContainer(Container) ` +
            `in your application before you established a connection and importing any entity.`);
    }
    const connection = connectionManager.get(connectionName);
    switch (repositoryType) {
        case Repository:
            return connection.getRepository(entityType);
        case MongoRepository:
            return connection.getMongoRepository(entityType);
        case TreeRepository:
            return connection.getTreeRepository(entityType);
        // if not the TypeORM's ones, there must be custom repository classes
        default:
            return connection.getCustomRepository(repositoryType);
    }
}
export function InjectRepository(entityTypeOrConnectionName, paramConnectionName = 'default') {
    return (object, propertyName, index) => {
        let entityType;
        let connectionName;
        let repositoryType;
        // handle first parameter overload
        connectionName = paramConnectionName;
        if (typeof entityTypeOrConnectionName === 'string') {
            connectionName = entityTypeOrConnectionName;
        }
        else if (typeof entityTypeOrConnectionName === 'function') {
            entityType = entityTypeOrConnectionName;
        }
        // if the decorator has been aplied to parameter (constructor injection)
        if (index !== undefined) {
            const paramTypes = Reflect.getOwnMetadata('design:paramtypes', object, propertyName);
            if (!paramTypes || !paramTypes[index]) {
                throw new ParamTypeMissingError(object, propertyName, index);
            }
            repositoryType = paramTypes[index];
        }
        // if the parameter has been aplied to class property
        else {
            const propertyType = Reflect.getOwnMetadata('design:type', object, propertyName);
            if (!propertyType) {
                throw new PropertyTypeMissingError(object, propertyName);
            }
            repositoryType = propertyType;
        }
        switch (repositoryType) {
            case Repository:
            case MongoRepository:
            case TreeRepository:
                if (!entityType) {
                    throw new EntityTypeMissingError(object, propertyName, index);
                }
        }
        Container.registerHandler({
            index,
            object: object,
            propertyName,
            value: () => getRepository(connectionName, repositoryType, entityType),
        });
    };
}
//# sourceMappingURL=InjectRepository.js.map